# IssueRunner Project Rules

## How to work

- Start to read the plan.md file, and follow the instructions in the plan.

## Architecture & Code Organization

- **Library Structure**: The project uses a three-tier architecture:
  - `IssueRunner.Core`: Core library containing Models, Services, and Commands
  - `IssueRunner.Cli`: Console application that references Core
  - `IssueRunner.Gui`: Avalonia GUI application that references Core
- Always maintain separation of concerns - business logic in Core, UI logic in GUI
- Services and Commands should be registered in Dependency Injection containers

## Avalonia GUI Development

- **ReactiveUI Integration**: Always call `.UseReactiveUI()` in `Program.cs` AppBuilder chain
- **Thread Safety**: All UI updates must be dispatched to the UI thread using `Avalonia.Threading.Dispatcher.UIThread.Post()` or `InvokeAsync()`
- **ReactiveCommand**: Use `ReactiveCommand.CreateFromTask()` for async commands - ReactiveUI handles thread marshaling automatically when `.UseReactiveUI()` is configured
- **Exception Handling**: Subscribe to `ThrownExceptions` on ReactiveCommands to catch and log errors
- **Console Output**: Use `RealTimeLogWriter` or similar streaming approach - never buffer all output until the end
- **Dialog Windows**: Use `ShowDialog()` for modal dialogs, ensure proper parent window is set

## Error Handling

- Always validate repository is loaded before executing commands
- Log errors to both UI (via `AppendLog`) and crash log file (`%LocalAppData%\IssueRunner\crash.log`)
- Use try-catch blocks around all command executions
- Provide meaningful error messages to users

## Console Output & Logging

- Console output from commands should be captured and displayed in real-time in the GUI
- Use streaming TextWriter implementations (like `RealTimeLogWriter`) rather than buffering
- Ensure console output is flushed and dispatched to UI thread immediately

## Code Style

- Follow existing C# patterns and conventions in the codebase
- Use nullable reference types appropriately
- Prefer `init` properties for immutable data models
- Use dependency injection for all services and commands
- Use Dependency inversion
- Use interfaces
- No method should be more than 20 lines long, break such methods into private methods
- If a class doesnt have an interface, but some services, tests would prefer that, then implement an interface for that class.

## Documentation

- Update `README.md` when adding new features or changing behavior
- Document new commands, options, and GUI features
- Include examples in documentation where helpful
- Make sure there is a blank line after headings
- Make sure fenced code blocks have a blank line before and after the fence
- Make sure there are no multiple blanks lines in sequence
- Lists should be surrounded by blank lines
- **CRITICAL: When checking documentation compliance, systematically verify EVERY list item (`-` or numbered) has a blank line before it, especially when lists follow sentences ending with colons (`:`) or periods (`.`). Use grep to find all list items and check each one's preceding line.**

## Testing & Validation

- Always validate inputs (repository paths, issue numbers, etc.) before processing
- Check for file existence before reading
- Handle missing files gracefully with informative error messages
- All tests shall be implemented as NUnit tests, using NSubstitute for mocking where required.

## GUI testing using Avalonia headless testing

- All GUI should be tested using the headless testing feature.
- **Async Command Testing**: When testing async ReactiveCommands (e.g., `ShowTestStatusCommand`), tests must be async and wait for the command to complete before asserting:
  - Make test methods `async Task` instead of `void`
  - Subscribe to the command execution and track completion using the `Subscribe()` overload with `onCompleted` callback
  - Use a timeout loop to wait for completion: `while (!completed && DateTime.Now < timeout) { await Task.Delay(50); }`
  - Add additional delays after command completion to allow UI thread operations to finish: `await Task.Delay(100)`
- **Repository Initialization**: Tests that set `RepositoryPath` must wait for repository initialization to complete:
  - `LoadRepository` runs asynchronously via `Task.Run` in the constructor
  - Add `await Task.Delay(300)` after setting `RepositoryPath` to allow initialization
  - Ensure test repository directory exists and contains required files (`repository.json`, `test-passes.json`, `test-fails.json`)
- **UI Thread Operations**: When updating UI properties in ViewModels that may be called from unit tests:
  - Check if already on UI thread using `Dispatcher.UIThread.CheckAccess()`
  - If on UI thread (or in unit test without dispatcher), execute directly
  - Otherwise, use `Dispatcher.UIThread.InvokeAsync()` for real GUI scenarios
  - This pattern allows code to work in both unit tests and real GUI: `if (Dispatcher.UIThread.CheckAccess()) { /* direct */ } else { await InvokeAsync(...) }`
- **Headless Test Base Setup**: `HeadlessTestBase` must properly configure test environment:
  - Create test repository directory structure with required files
  - Set up `IEnvironmentService` mock to track root changes via `AddRoot` using closures: `envService.Root.Returns(_ => currentRoot)`
  - Create empty test result files to prevent `FileNotFoundException` during `TestStatusViewModel.LoadDataAsync`

## Package Management

- The "Local" feed points to `C:\nuget` (not `C:\local`)
- Local feed should run with prerelease enabled
- Check if feed already exists before trying to add it - don't show misleading warnings

## File Paths

- Use `Path.Combine()` for cross-platform compatibility
- Repository root is stored in `IEnvironmentService.Root`
- Metadata files are in `Tools/issues_metadata.json`
- Test results are in `test-passes.json` and `test-fails.json` at repository root

## Best Practices

- Never use `async void` - always use `async Task`
- Use `ReactiveCommand` for all button commands in GUI
- Ensure all async operations are properly awaited
- Don't block the UI thread - use background tasks for long-running operations
- Always restore console output after redirecting it
